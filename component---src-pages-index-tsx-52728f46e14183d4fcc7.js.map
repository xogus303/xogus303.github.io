{"version":3,"file":"component---src-pages-index-tsx-52728f46e14183d4fcc7.js","mappings":"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","sources":["webpack://gatsby-starter-default/./node_modules/@react-hooks-library/core/index.esm.js","webpack://gatsby-starter-default/./src/hooks/useIntervalWriteText.tsx","webpack://gatsby-starter-default/./src/hooks/useScrollOrSwipeUp.ts","webpack://gatsby-starter-default/./src/components/Main/Introduction.tsx","webpack://gatsby-starter-default/./src/components/Main/PostItem.tsx","webpack://gatsby-starter-default/./src/hooks/useInfiniteScroll.tsx","webpack://gatsby-starter-default/./src/components/Main/PostList.tsx","webpack://gatsby-starter-default/./src/pages/index.tsx"],"sourcesContent":["import { useEffect, useState, useRef, useCallback, useLayoutEffect } from 'react';\n\n/**\r\n * Run a function when a component is mounted.\r\n *\r\n * @param callback function to be executed\r\n */\r\nfunction useMount(callback) {\r\n    useEffect(callback, []);\r\n}\n\n/**\r\n * Reactive media query hook that returns the truthy value of the media query.\r\n *\r\n * @param {string} query\r\n * @returns {boolean} boolean value of the query\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useMediaQuery\r\n */\r\nfunction useMediaQuery(query) {\r\n    const [matches, setMatches] = useState(false);\r\n    useMount(() => {\r\n        setMatches(window.matchMedia(query).matches);\r\n    });\r\n    useEffect(() => {\r\n        const mediaQuery = window.matchMedia(query);\r\n        const handler = (event) => {\r\n            setMatches(event.matches);\r\n        };\r\n        // Add event listener for old safari browsers\r\n        'addEventListener' in mediaQuery\r\n            ? mediaQuery.addEventListener('change', handler)\r\n            : mediaQuery.addListener(handler);\r\n        return () => {\r\n            'addEventListener' in mediaQuery\r\n                ? mediaQuery.removeEventListener('change', handler)\r\n                : mediaQuery.removeListener(handler);\r\n        };\r\n    }, [query]);\r\n    return matches;\r\n}\n\n/**\r\n * Breakpoints from Tailwind V2\r\n *\r\n * @see https://tailwindcss.com/docs/breakpoints\r\n */\r\nconst breakpointsTailwind = {\r\n    sm: 640,\r\n    md: 768,\r\n    lg: 1024,\r\n    xl: 1280,\r\n    '2xl': 1536\r\n};\r\n/**\r\n * Breakpoints from Bootstrap V5\r\n *\r\n * @see https://getbootstrap.com/docs/5.0/layout/breakpoints\r\n */\r\nconst breakpointsBootstrapV5 = {\r\n    sm: 576,\r\n    md: 768,\r\n    lg: 992,\r\n    xl: 1200,\r\n    xxl: 1400\r\n};\r\n/**\r\n * Breakpoints from Vuetify V2\r\n *\r\n * @see https://vuetifyjs.com/en/features/breakpoints\r\n */\r\nconst breakpointsVuetify = {\r\n    xs: 600,\r\n    sm: 960,\r\n    md: 1264,\r\n    lg: 1904\r\n};\r\n/**\r\n * Breakpoints from Ant Design\r\n *\r\n * @see https://ant.design/components/layout/#breakpoint-width\r\n */\r\nconst breakpointsAntDesign = {\r\n    xs: 480,\r\n    sm: 576,\r\n    md: 768,\r\n    lg: 992,\r\n    xl: 1200,\r\n    xxl: 1600\r\n};\r\n/**\r\n * Sematic Breakpoints\r\n */\r\nconst breakpointsSematic = {\r\n    mobileS: 320,\r\n    mobileM: 375,\r\n    mobileL: 425,\r\n    tablet: 768,\r\n    laptop: 1024,\r\n    laptopL: 1440,\r\n    desktop4K: 2560\r\n};\n\n/* eslint-disable @typescript-eslint/ban-types */\r\n/**\r\n * Check if we're on the server or client side\r\n */\r\nconst isClient = typeof window !== 'undefined';\r\n/**\r\n * Check if object is a react ref\r\n */\r\nconst isRef = (obj) => obj !== null &&\r\n    typeof obj === 'object' &&\r\n    Object.prototype.hasOwnProperty.call(obj, 'current');\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\n// eslint-disable-next-line @typescript-eslint/no-empty-function\r\nconst noop = () => { };\r\nconst round = (num) => Math.round(num * 1e2) / 1e2;\n\n/**\r\n * Accepts either a ref object or a dom node and returns a dom node\r\n *\r\n * @param target - ref or a dom node\r\n * @returns dom noe\r\n */\r\nfunction unRef(target) {\r\n    const element = isRef(target)\r\n        ? target.current\r\n        : target;\r\n    return element;\r\n}\n\nconst _window =  isClient ? window : undefined;\r\nconst _document =  isClient ? window.document : undefined;\r\nconst _navigator =  isClient\r\n    ? window.navigator\r\n    : undefined;\n\nfunction match(query) {\r\n    if (!_window)\r\n        return false;\r\n    return _window.matchMedia(query).matches;\r\n}\r\n/**\r\n * Reactive hooks and utilities to be used with user provided breakpoints.\r\n *\r\n * @param {string} breakpoints\r\n * @returns functions to be used as hooks\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/BreakPointHooks\r\n */\r\nfunction BreakPointHooks(breakpoints) {\r\n    return {\r\n        /**\r\n         * Hook that returns a boolean if screen width is greater than given breakpoint.\r\n         *\r\n         * @param k {string} breakpoint\r\n         * @returns boolean\r\n         *\r\n         * @see https://react-hooks-library.vercel.app/core/BreakPointHooks\r\n         **/\r\n        useGreater: (k) => {\r\n            return useMediaQuery(`(min-width: ${breakpoints[k]}px)`);\r\n        },\r\n        /**\r\n         * Hook that returns a boolean if screen width is smaller than given breakpoint.\r\n         *\r\n         * @param k {string} breakpoint\r\n         * @param k {string} breakpoint\r\n         *\r\n         * @returns boolean\r\n         *\r\n         * @see https://react-hooks-library.vercel.app/core/BreakPointHooks\r\n         **/\r\n        useSmaller: (k) => {\r\n            return useMediaQuery(`(max-width: ${breakpoints[k]}px)`);\r\n        },\r\n        /**\r\n         * Hook that returns a boolean if screen width is between two given breakpoint.\r\n         *\r\n         * @param a {string} breakpoint\r\n         * @param b {string} breakpoint\r\n         *\r\n         * @returns boolean\r\n         *\r\n         * @see https://react-hooks-library.vercel.app/core/BreakPointHooks\r\n         **/\r\n        useBetween: (a, b) => {\r\n            return useMediaQuery(`(min-width: ${breakpoints[a]}px) and (max-width: ${breakpoints[b]}px)`);\r\n        },\r\n        /**\r\n         * Utility function that returns a boolean if screen width is greater than given breakpoint.\r\n         *\r\n         * @param k {string} breakpoint\r\n         *\r\n         * @see https://react-hooks-library.vercel.app/core/BreakPointHooks\r\n         **/\r\n        isGreater(k) {\r\n            return match(`(min-width: ${breakpoints[k]}px)`);\r\n        },\r\n        /**\r\n         * Utility function that returns a boolean if screen width is smaller than given breakpoint.\r\n         *\r\n         * @param k {string} breakpoint\r\n         *\r\n         * @see https://react-hooks-library.vercel.app/core/BreakPointHooks\r\n         **/\r\n        isSmaller(k) {\r\n            return match(`(max-width: ${breakpoints[k]}px)`);\r\n        },\r\n        /**\r\n         * Utility function that returns a boolean if screen width is between two given breakpoint.\r\n         *\r\n         * @param k {string} breakpoint\r\n         *\r\n         * @see https://react-hooks-library.vercel.app/core/BreakPointHooks\r\n         **/\r\n        isInBetween(a, b) {\r\n            return match(`(min-width: ${breakpoints[a]}px) and (max-width: ${breakpoints[b]}px)`);\r\n        }\r\n    };\r\n}\n\nfunction useEventListener(...args) {\r\n    let target = _window;\r\n    let event;\r\n    let listener;\r\n    let options;\r\n    isString(args[0])\r\n        ? ([event, listener, options] = args)\r\n        : ([target, event, listener, options] = args);\r\n    const savedListener = useRef(listener);\r\n    const cleanup = useRef(noop);\r\n    useEffect(() => {\r\n        savedListener.current = listener;\r\n    }, [listener]);\r\n    useEffect(() => {\r\n        const el = unRef(target);\r\n        if (!isClient || !el)\r\n            return;\r\n        el.addEventListener(event, savedListener.current, options);\r\n        cleanup.current = () => {\r\n            el.removeEventListener(event, savedListener.current, options);\r\n        };\r\n        return cleanup.current;\r\n    }, [event, target, options]);\r\n    return cleanup.current;\r\n}\n\n/**\r\n * Reactive document.activeElement, returns a reference to current active element\r\n *\r\n * @returns current active element (DOM node)\r\n **/\r\nfunction useActiveElement() {\r\n    const [activeElement, setActiveElement] = useState(() => _document === null || _document === void 0 ? void 0 : _document.activeElement);\r\n    useEventListener('focus', () => setActiveElement(_document === null || _document === void 0 ? void 0 : _document.activeElement), true);\r\n    useEventListener('blur', () => setActiveElement(null), true);\r\n    return { activeElement };\r\n}\n\n/**\r\n * Returns a current execution state of an async function.\r\n * Use it to orchestrate async actions in UI.\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useAsyncCallback\r\n */\r\nfunction useAsyncCallback(callback) {\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [isSuccess, setIsSuccess] = useState(false);\r\n    const [error, setError] = useState(false);\r\n    const [data, setData] = useState();\r\n    const _callback = useCallback(async (...args) => {\r\n        try {\r\n            setIsLoading(true);\r\n            const results = await callback(...args);\r\n            setData(results);\r\n            setIsSuccess(true);\r\n            return results;\r\n        }\r\n        catch (e) {\r\n            setError(true);\r\n            throw e;\r\n        }\r\n        finally {\r\n            setIsLoading(false);\r\n        }\r\n    }, [callback]);\r\n    return [{ data, error, isLoading, isSuccess }, _callback];\r\n}\n\n/**\r\n * Listen for clicks outside of an element.\r\n *\r\n * @param target\r\n * @param handler\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/onClickOutside\r\n */\r\nfunction useClickOutside(target, handler, options = {}) {\r\n    const { event = 'pointerdown' } = options;\r\n    const listener = useCallback((event) => {\r\n        const el = unRef(target);\r\n        if (!el)\r\n            return;\r\n        if (el === event.target || event.composedPath().includes(el))\r\n            return;\r\n        handler(event);\r\n    }, [handler, target]);\r\n    return useEventListener(_window, event, listener, { passive: true });\r\n}\n\n/**\r\n * Used to debounce a quickly changing value.\r\n * Will return the latest value after a specified amount of time.\r\n *\r\n * @param {T} value\r\n * @param timeout\r\n * @returns {Readonly<T>} latest value\r\n * @see https://react-hooks-library.vercel.app/core/useDebounce\r\n */\r\nfunction useDebounce(value, timeout) {\r\n    const [state, setState] = useState(value);\r\n    useEffect(() => {\r\n        const tick = setTimeout(() => setState(value), timeout);\r\n        return () => clearTimeout(tick);\r\n    }, [value, timeout]);\r\n    if (timeout <= 0)\r\n        return value;\r\n    return state;\r\n}\n\n/**\r\n * A useEffect hook does that not run on mount, but only on subsequent updates.\r\n *\r\n * @deprecated This hook breaks in React 18's strict mode, since it's not idempotent\r\n *\r\n * @param effect\r\n * @param deps\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useEffectAfterMount\r\n */\r\nfunction useEffectAfterMount(effect, deps) {\r\n    const isMounted = useRef(false);\r\n    useEffect(() => {\r\n        let cleanup = undefined;\r\n        if (isMounted.current) {\r\n            cleanup = effect();\r\n        }\r\n        isMounted.current = true;\r\n        return cleanup;\r\n    }, deps);\r\n}\n\n/**\r\n * React FontFace, a hook to load fonts asynchronously\r\n *\r\n * @param family\r\n * @param source\r\n * @param descriptors\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useFont\r\n */\r\nfunction useFont(family, source, descriptors) {\r\n    const [loaded, setLoaded] = useState(true);\r\n    const [error, setError] = useState(false);\r\n    const [font, setFont] = useState(null);\r\n    useEffect(() => {\r\n        const font = new FontFace(family, `url(${source})`, descriptors);\r\n        setFont(font);\r\n        setLoaded(false);\r\n        font\r\n            .load()\r\n            .then(() => document.fonts.add(font))\r\n            .catch(() => setError(true))\r\n            .finally(() => setLoaded(true));\r\n    }, [descriptors, family, source]);\r\n    return { loaded, error, font };\r\n}\n\n/**\r\n * Hook that returns whether or not the component has mounted.\r\n * Useful in SSR frameworks like Next or Gatsby.\r\n *\r\n * @returns hasMounted\r\n */\r\nfunction useHasMounted() {\r\n    const [hasMounted, setHasMounted] = useState(false);\r\n    useMount(() => {\r\n        setHasMounted(true);\r\n    });\r\n    return hasMounted;\r\n}\n\n/**\r\n *\r\n * Detect if a dom element is hovered\r\n *\r\n * @param target - The element to listen to\r\n * @returns\r\n */\r\nfunction useHover(target) {\r\n    const [isHovered, setIsHovered] = useState(false);\r\n    useEffect(() => {\r\n        const el = unRef(target);\r\n        if (!el)\r\n            return;\r\n        const onMouseEnter = () => setIsHovered(true);\r\n        const onMouseLeave = () => setIsHovered(false);\r\n        el.addEventListener('mouseenter', onMouseEnter);\r\n        el.addEventListener('mouseleave', onMouseLeave);\r\n        return () => {\r\n            el.removeEventListener('mouseenter', onMouseEnter);\r\n            el.removeEventListener('mouseleave', onMouseLeave);\r\n        };\r\n    }, [target]);\r\n    return isHovered;\r\n}\n\n/**\r\n * Is a feature supported in the browser or not\r\n *\r\n * @param predicate - predicate to check if the feature is supported\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useIsSupported\r\n */\r\nfunction useIsSupported(predicate) {\r\n    const [isSupported, setIsSupported] = useState(false);\r\n    useMount(() => {\r\n        setIsSupported(predicate());\r\n    });\r\n    return isSupported;\r\n}\n\n/**\r\n * Run a function when component is unmounted.\r\n *\r\n * @param callback function to be executed\r\n */\r\nfunction useUnMount(func) {\r\n    useEffect(() => {\r\n        return func;\r\n    }, [func]);\r\n}\n\n/**\r\n * Reactive intersection observer.\r\n *\r\n * @param target - React ref or DOM node\r\n * @param options - Options passed to mutation observer\r\n * @param callback - callback to execute when mutations are observed\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver IntersectionObserver MDN\r\n * @see https://react-hooks-library.vercel.app/core/useIntersectionObserver\r\n */\r\nfunction useIntersectionObserver(target, options = {}, callback = noop) {\r\n    const { root = _document, rootMargin = '0px', threshold = 0 } = options;\r\n    const [inView, setInView] = useState(false);\r\n    const [entry, setEntry] = useState(null);\r\n    const isSupported = useIsSupported(() => 'IntersectionObserver' in window);\r\n    const observer = useRef(null);\r\n    const stop = useCallback(() => {\r\n        if (!observer.current)\r\n            return;\r\n        observer.current.disconnect();\r\n        observer.current = null;\r\n    }, []);\r\n    useUnMount(stop);\r\n    useEffect(() => {\r\n        var _a;\r\n        const el = unRef(target);\r\n        const rootEl = unRef(root);\r\n        if (!(isSupported && el && rootEl))\r\n            return;\r\n        observer.current = new window.IntersectionObserver((entries, observer) => {\r\n            const thresholds = Array.isArray(threshold) ? threshold : [threshold];\r\n            entries.forEach((entry) => {\r\n                const inView = entry.isIntersecting &&\r\n                    thresholds.some((threshold) => entry.intersectionRatio >= threshold);\r\n                setInView(inView);\r\n                setEntry(entry);\r\n            });\r\n            callback(entries, observer);\r\n        }, {\r\n            root: rootEl,\r\n            rootMargin,\r\n            threshold\r\n        });\r\n        (_a = observer.current) === null || _a === void 0 ? void 0 : _a.observe(el);\r\n        return stop;\r\n    }, [callback, isSupported, root, rootMargin, stop, target, threshold]);\r\n    return {\r\n        isSupported,\r\n        stop,\r\n        inView,\r\n        entry\r\n    };\r\n}\n\n/**\r\n * Run a function repeatedly at a specified interval.\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useInterval\r\n */\r\nfunction useInterval(callback, delay, options) {\r\n    const { immediate = false, paused = false } = options || {};\r\n    const savedCallback = useRef(callback);\r\n    const tickId = useRef();\r\n    useEffect(() => {\r\n        savedCallback.current = callback;\r\n        if (!paused && immediate) {\r\n            callback();\r\n        }\r\n    }, [callback, immediate, paused]);\r\n    useEffect(() => {\r\n        if (tickId.current && paused) {\r\n            clearInterval(tickId.current);\r\n            return;\r\n        }\r\n        tickId.current = setInterval(() => savedCallback.current(), delay);\r\n        return () => tickId.current && clearInterval(tickId.current);\r\n    }, [delay, paused]);\r\n}\n\n/**\r\n * Listen for keyboard keys being stroked.\r\n *\r\n * @param keys\r\n * @param handler\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useKeyStroke\r\n */\r\nfunction useKeyStroke(keys, handler, options = {}) {\r\n    const { target = _window, eventName = 'keydown', passive = false, code = false } = options;\r\n    const listener = useCallback((e) => {\r\n        const eventKey = code ? e.code : e.key;\r\n        keys.includes(eventKey) && handler(e);\r\n    }, [code, handler, keys]);\r\n    return useEventListener(target, eventName, listener, { passive });\r\n}\r\n/**\r\n * Listen for keyboard keys on keydown.\r\n *\r\n * @param keys\r\n * @param handler\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useKeyStroke\r\n */\r\nfunction useKeyDown(keys, handler, options = {}) {\r\n    return useKeyStroke(keys, handler, Object.assign(Object.assign({}, options), { eventName: 'keydown' }));\r\n}\r\n/**\r\n * Listen for keyboard keys on keypress.\r\n *\r\n * @param keys\r\n * @param handler\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/onKeyStroke\r\n */\r\nfunction useKeyPressed(keys, handler, options = {}) {\r\n    return useKeyStroke(keys, handler, Object.assign(Object.assign({}, options), { eventName: 'keypress' }));\r\n}\r\n/**\r\n * Listen for keyboard keys on keyup.\r\n *\r\n * @param keys\r\n * @param handler\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/onKeyStroke\r\n */\r\nfunction useKeyUp(keys, handler, options = {}) {\r\n    return useKeyStroke(keys, handler, Object.assign(Object.assign({}, options), { eventName: 'keyup' }));\r\n}\n\n/**\r\n * Modified `useState` hook that syncs with localStorage.\r\n *\r\n * @param key\r\n * @param initialValue\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useLocalStorage\r\n */\r\nfunction useLocalStorage(key, initialValue, options) {\r\n    const [storedValue, setStoredValue] = useState(initialValue);\r\n    const { deserialize = JSON.parse, serialize = JSON.stringify } = options || {};\r\n    useMount(() => {\r\n        try {\r\n            const item = localStorage.getItem(key);\r\n            item && setStoredValue(deserialize(item));\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n        }\r\n    });\r\n    const setValue = useCallback((value) => {\r\n        try {\r\n            localStorage.setItem(key, serialize(value));\r\n            setStoredValue(value);\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n        }\r\n    }, [key, serialize]);\r\n    return [storedValue, setValue];\r\n}\n\nconst buildState = (trigger) => {\r\n    const { state, length } = (_window === null || _window === void 0 ? void 0 : _window.history) || {};\r\n    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (_window === null || _window === void 0 ? void 0 : _window.location) || {};\r\n    return {\r\n        trigger,\r\n        state,\r\n        length,\r\n        hash,\r\n        host,\r\n        hostname,\r\n        href,\r\n        origin,\r\n        pathname,\r\n        port,\r\n        protocol,\r\n        search\r\n    };\r\n};\r\n/**\r\n * Reactive browser location.\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useLocation\r\n *\r\n */\r\nfunction useLocation() {\r\n    const [state, setState] = useState(null);\r\n    useMount(() => {\r\n        setState(buildState('load'));\r\n    });\r\n    useEventListener('popstate', () => setState(buildState('popstate')), {\r\n        passive: true\r\n    });\r\n    useEventListener('hashchange', () => setState(buildState('hashchange')), {\r\n        passive: true\r\n    });\r\n    return state;\r\n}\n\n/**\r\n * Reactive `mediaDevices.getUserMedia` streaming\r\n *\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useMediaStream\r\n */\r\nfunction useMediaStream(options = {}) {\r\n    const { audioDeviceId, videoDeviceId, autoSwitch } = options;\r\n    const isSupported = useIsSupported(() => { var _a; return !!((_a = _navigator === null || _navigator === void 0 ? void 0 : _navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia); });\r\n    const stream = useRef(null);\r\n    const ref = useRef(null);\r\n    const [isPlaying, setPlaying] = useState(false);\r\n    const [isAudioMuted, setAudioMuted] = useState(false);\r\n    const [isVideoMuted, setVideoMuted] = useState(false);\r\n    const getDeviceOptions = useCallback((device) => {\r\n        if (device === 'none' || device === false)\r\n            return false;\r\n        if (device === null)\r\n            return true;\r\n        return {\r\n            deviceId: device\r\n        };\r\n    }, []);\r\n    const play = useCallback(async () => {\r\n        var _a;\r\n        if (!isSupported || stream.current)\r\n            return;\r\n        stream.current =\r\n            (_a = (await (_navigator === null || _navigator === void 0 ? void 0 : _navigator.mediaDevices.getUserMedia({\r\n                video: getDeviceOptions(videoDeviceId),\r\n                audio: getDeviceOptions(audioDeviceId)\r\n            })))) !== null && _a !== void 0 ? _a : null;\r\n        setPlaying(true);\r\n        return stream.current;\r\n    }, [audioDeviceId, getDeviceOptions, isSupported, videoDeviceId]);\r\n    const stop = useCallback(() => {\r\n        var _a;\r\n        setPlaying(false);\r\n        (_a = stream.current) === null || _a === void 0 ? void 0 : _a.getTracks().forEach((t) => t.stop());\r\n        stream.current = null;\r\n    }, []);\r\n    const restart = useCallback(async () => {\r\n        stop();\r\n        return await play();\r\n    }, [play, stop]);\r\n    const muteAudio = useCallback(() => {\r\n        var _a;\r\n        setAudioMuted(true);\r\n        (_a = stream.current) === null || _a === void 0 ? void 0 : _a.getAudioTracks().forEach((t) => (t.enabled = false));\r\n    }, []);\r\n    const unMuteAudio = useCallback(() => {\r\n        var _a;\r\n        setAudioMuted(false);\r\n        (_a = stream.current) === null || _a === void 0 ? void 0 : _a.getAudioTracks().forEach((t) => (t.enabled = true));\r\n    }, []);\r\n    const muteVideo = useCallback(() => {\r\n        var _a;\r\n        setVideoMuted(true);\r\n        (_a = stream.current) === null || _a === void 0 ? void 0 : _a.getVideoTracks().forEach((t) => (t.enabled = false));\r\n    }, []);\r\n    const unMuteVideo = useCallback(() => {\r\n        var _a;\r\n        setVideoMuted(false);\r\n        (_a = stream.current) === null || _a === void 0 ? void 0 : _a.getVideoTracks().forEach((t) => (t.enabled = true));\r\n    }, []);\r\n    const pause = useCallback(() => {\r\n        muteAudio();\r\n        muteVideo();\r\n    }, [muteAudio, muteVideo]);\r\n    const resume = useCallback(() => {\r\n        unMuteAudio();\r\n        unMuteVideo();\r\n    }, [unMuteAudio, unMuteVideo]);\r\n    useEffect(() => {\r\n        if (!ref.current)\r\n            return;\r\n        ref.current.srcObject = stream.current;\r\n    }, [isPlaying]);\r\n    useEffect(() => {\r\n        if (autoSwitch && stream.current)\r\n            restart();\r\n    }, [videoDeviceId, audioDeviceId, autoSwitch, restart]);\r\n    return {\r\n        isSupported,\r\n        ref,\r\n        stream,\r\n        isPlaying,\r\n        play,\r\n        stop,\r\n        restart,\r\n        isAudioMuted,\r\n        muteAudio,\r\n        unMuteAudio,\r\n        isVideoMuted,\r\n        muteVideo,\r\n        unMuteVideo,\r\n        pause,\r\n        resume,\r\n        isPaused: isAudioMuted && isVideoMuted\r\n    };\r\n}\n\n/**\r\n * Run a function synchronously when a component is mounted and after DOM is painted.\r\n *\r\n * @param callback function to be executed\r\n */\r\nfunction useMountSync(callback) {\r\n    useLayoutEffect(callback, []);\r\n}\n\n/**\r\n *\r\n * Reactive mouse position based by page or client\r\n *\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useMouse\r\n */\r\nfunction useMouse(options = {}) {\r\n    const { touch = true, type = 'client', resetOnTouchEnds = false, initialValue = { x: 0, y: 0 } } = options;\r\n    const [x, setX] = useState(initialValue.x);\r\n    const [y, setY] = useState(initialValue.y);\r\n    const [source, setSource] = useState(null);\r\n    useEffect(() => {\r\n        const mouseHandler = (event) => {\r\n            setSource('mouse');\r\n            if (type === 'page') {\r\n                setX(event.pageX);\r\n                setY(event.pageY);\r\n            }\r\n            else if (type === 'client') {\r\n                setX(event.clientX);\r\n                setY(event.clientY);\r\n            }\r\n        };\r\n        const reset = () => {\r\n            setX(initialValue.x);\r\n            setY(initialValue.y);\r\n        };\r\n        const touchHandler = (event) => {\r\n            if (event.touches.length > 0) {\r\n                setSource('touch');\r\n                if (type === 'page') {\r\n                    setX(event.touches[0].pageX);\r\n                    setY(event.touches[0].pageY);\r\n                }\r\n                else if (type === 'client') {\r\n                    setX(event.touches[0].clientX);\r\n                    setY(event.touches[0].clientY);\r\n                }\r\n            }\r\n        };\r\n        window.addEventListener('mousemove', mouseHandler, { passive: true });\r\n        window.addEventListener('dragover', mouseHandler, { passive: true });\r\n        if (touch) {\r\n            window.addEventListener('touchstart', touchHandler, { passive: true });\r\n            window.addEventListener('touchmove', touchHandler, { passive: true });\r\n            if (resetOnTouchEnds)\r\n                window.addEventListener('touchend', reset, { passive: true });\r\n        }\r\n        return () => {\r\n            window.removeEventListener('mousemove', mouseHandler);\r\n            window.removeEventListener('dragover', mouseHandler);\r\n            if (touch) {\r\n                window.removeEventListener('touchstart', touchHandler);\r\n                window.removeEventListener('touchmove', touchHandler);\r\n                if (resetOnTouchEnds)\r\n                    window.removeEventListener('touchend', reset);\r\n            }\r\n        };\r\n    }, [initialValue.x, initialValue.y, resetOnTouchEnds, touch, type]);\r\n    return { x, y, source };\r\n}\n\n/**\r\n * Watch for changes being made to the DOM tree.\r\n *\r\n * @param target - React ref or DOM node\r\n * @param callback - callback to execute when mutations are observed\r\n * @param options - Options passed to mutation observer\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver MutationObserver MDN\r\n * @see https://react-hooks-library.vercel.app/core/useMutationObserver\r\n */\r\nfunction useMutationObserver(target, callback, options = {}) {\r\n    const observer = useRef(null);\r\n    const isSupported = useIsSupported(() => !!(_window === null || _window === void 0 ? void 0 : _window.IntersectionObserver));\r\n    const stop = useCallback(() => {\r\n        if (!observer.current)\r\n            return;\r\n        observer.current.disconnect();\r\n        observer.current = null;\r\n    }, []);\r\n    useUnMount(stop);\r\n    useEffect(() => {\r\n        var _a;\r\n        const el = unRef(target);\r\n        if (!(isSupported && el && _window))\r\n            return;\r\n        observer.current = new _window.MutationObserver(callback);\r\n        (_a = observer.current) === null || _a === void 0 ? void 0 : _a.observe(el, options);\r\n        return stop;\r\n    }, [callback, stop, options, target, isSupported]);\r\n    return {\r\n        isSupported,\r\n        stop\r\n    };\r\n}\n\n/**\r\n * Reactive Network status.\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useNetwork\r\n */\r\nfunction useNetwork() {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const isSupported = useIsSupported(() => !!(_navigator === null || _navigator === void 0 ? void 0 : _navigator.connection));\r\n    const [isOnline, setIsOnline] = useState(true);\r\n    const [offlineAt, setOfflineAt] = useState(undefined);\r\n    const connection = useRef(undefined);\r\n    const rerender = useState({})[1];\r\n    useMount(() => {\r\n        if (!_navigator)\r\n            return;\r\n        setIsOnline(_navigator.onLine);\r\n        setOfflineAt(isOnline ? undefined : Date.now());\r\n        const _connection = _navigator === null || _navigator === void 0 ? void 0 : _navigator.connection;\r\n        if (!_connection)\r\n            return;\r\n        connection.current = _connection;\r\n        connection.current.onchange = () => rerender({});\r\n    });\r\n    useEventListener('offline', () => {\r\n        setIsOnline(false);\r\n        setOfflineAt(Date.now());\r\n    });\r\n    useEventListener('online', () => {\r\n        setIsOnline(true);\r\n    });\r\n    return {\r\n        isSupported,\r\n        isOnline,\r\n        offlineAt,\r\n        saveData: (_a = connection.current) === null || _a === void 0 ? void 0 : _a.saveData,\r\n        rtt: (_b = connection.current) === null || _b === void 0 ? void 0 : _b.rtt,\r\n        downlink: (_c = connection.current) === null || _c === void 0 ? void 0 : _c.downlink,\r\n        downlinkMax: (_d = connection.current) === null || _d === void 0 ? void 0 : _d.downlinkMax,\r\n        effectiveType: (_e = connection.current) === null || _e === void 0 ? void 0 : _e.effectiveType,\r\n        type: (_f = connection.current) === null || _f === void 0 ? void 0 : _f.type\r\n    };\r\n}\n\n/**\r\n * Reactive online status\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useOnline\r\n */\r\nfunction useOnline() {\r\n    const [online, setOnline] = useState(false);\r\n    useMount(() => {\r\n        setOnline(navigator.onLine);\r\n    });\r\n    useEventListener('offline', () => {\r\n        setOnline(false);\r\n    });\r\n    useEventListener('online', () => {\r\n        setOnline(true);\r\n    });\r\n    return online;\r\n}\n\n/**\r\n * Reactive prefers-color-scheme media query.\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/usePreferredColorScheme\r\n */\r\nfunction usePreferredColorScheme() {\r\n    const isDark = useMediaQuery('(prefers-color-scheme: dark)');\r\n    return isDark ? 'dark' : 'light';\r\n}\n\n/**\r\n * Returns the value of the argument from the previous render\r\n * @param {T} value\r\n * @returns {T | undefined} previous value\r\n * @see https://react-hooks-library.vercel.app/core/usePrevious\r\n */\r\nfunction usePrevious(value) {\r\n    const ref = useRef();\r\n    useEffect(() => {\r\n        ref.current = value;\r\n    }, [value]);\r\n    return ref.current;\r\n}\n\n/**\r\n * Reactive screen sharing\r\n *\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useScreenShare\r\n */\r\nfunction useScreenShare(options = {}) {\r\n    const { audio = true, video = true } = options;\r\n    const isSupported = useIsSupported(() => { var _a; return !!((_a = _navigator === null || _navigator === void 0 ? void 0 : _navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getDisplayMedia); });\r\n    const stream = useRef(null);\r\n    const ref = useRef(null);\r\n    const [isPlaying, setPlaying] = useState(false);\r\n    const play = useCallback(async () => {\r\n        var _a;\r\n        if (!isSupported || !ref.current)\r\n            return;\r\n        stream.current =\r\n            (_a = (await (_navigator === null || _navigator === void 0 ? void 0 : _navigator.mediaDevices.getDisplayMedia({\r\n                audio,\r\n                video\r\n            })))) !== null && _a !== void 0 ? _a : null;\r\n        setPlaying(true);\r\n        return stream.current;\r\n    }, [audio, isSupported, video]);\r\n    const stop = useCallback(() => {\r\n        var _a;\r\n        (_a = stream.current) === null || _a === void 0 ? void 0 : _a.getTracks().forEach((t) => t.stop());\r\n        stream.current = null;\r\n        setPlaying(false);\r\n    }, []);\r\n    useEffect(() => {\r\n        var _a;\r\n        if (!ref.current)\r\n            return;\r\n        ref.current.srcObject = stream.current;\r\n        // Handle os native stop screen sharing buttons\r\n        (_a = stream.current) === null || _a === void 0 ? void 0 : _a.getVideoTracks()[0].addEventListener('ended', stop);\r\n    }, [isPlaying, stop]);\r\n    return {\r\n        isSupported,\r\n        isPlaying,\r\n        ref,\r\n        stream,\r\n        play,\r\n        stop\r\n    };\r\n}\n\n/**\r\n * Reactive scroll values for a react ref or a dom node\r\n *\r\n * @param target - dom node or react ref\r\n * @param callback - callback to run on scroll\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useScroll\r\n */\r\nfunction useScroll(target = _document === null || _document === void 0 ? void 0 : _document.documentElement, callback) {\r\n    const getPositions = () => {\r\n        const el = unRef(target);\r\n        if (!el)\r\n            return;\r\n        return {\r\n            x: round(el.scrollLeft / (el.scrollWidth - el.clientWidth)),\r\n            y: round(el.scrollTop / (el.scrollHeight - el.clientHeight))\r\n        };\r\n    };\r\n    useEventListener(target, 'scroll', () => {\r\n        const newScrollValues = getPositions();\r\n        if (!newScrollValues)\r\n            return;\r\n        const { x, y } = newScrollValues;\r\n        callback({ scrollX: x, scrollY: y });\r\n    }, {\r\n        capture: false,\r\n        passive: true\r\n    });\r\n}\n\n/**\r\n *\r\n * A hook to scroll an element into view on mounting.\r\n *\r\n * @param options {UseScrollIntoViewOptions}\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useScrollIntoView\r\n */\r\nfunction useScrollIntoView(target, options = {}) {\r\n    const { behavior = 'auto', block = 'start', inline = 'nearest', scrollMargin = '0px', predicate = true } = options;\r\n    useMount(() => {\r\n        const el = unRef(target);\r\n        if (!(el && (isFunction(predicate) ? predicate() : predicate))) {\r\n            return;\r\n        }\r\n        el.style.scrollMargin = scrollMargin;\r\n        el.scrollIntoView({\r\n            behavior,\r\n            block,\r\n            inline\r\n        });\r\n    });\r\n}\n\n/**\r\n * Modified `useState` hook that syncs with useSessionStorage.\r\n *\r\n * @param key\r\n * @param initialValue\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useSessionStorage\r\n */\r\nfunction useSessionStorage(key, initialValue, options) {\r\n    const [storedValue, setStoredValue] = useState(initialValue);\r\n    const { deserialize = JSON.parse, serialize = JSON.stringify } = options || {};\r\n    useMount(() => {\r\n        try {\r\n            const item = sessionStorage.getItem(key);\r\n            item && setStoredValue(deserialize(item));\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n        }\r\n    });\r\n    const setValue = useCallback((value) => {\r\n        try {\r\n            setStoredValue(value);\r\n            sessionStorage.setItem(key, serialize(value));\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n        }\r\n    }, [key, serialize]);\r\n    return [storedValue, setValue];\r\n}\n\n/**\r\n * useState hook with custom compare function to avoid re-rendering\r\n * when state is the same, compares with previous state\r\n *\r\n *\r\n * Note: create a custom compare function, outside of the hook to keep\r\n * a stable reference, otherwise it will be recreated on every render\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useStateCompare\r\n */\r\nfunction useStateCompare({ initialValue, compare }) {\r\n    const [state, _setState] = useState(initialValue);\r\n    const setState = useCallback((value) => {\r\n        typeof value === 'function'\r\n            ? _setState(value)\r\n            : _setState((oldValue) => compare(oldValue, value));\r\n    }, [compare]);\r\n    return [state, setState];\r\n}\n\n/**\r\n *\r\n * useState with built in undo and redo history control\r\n *\r\n * @param defaultValue\r\n * @param options\r\n * @returns\r\n */\r\nfunction useStateHistory(defaultValue, options = {}) {\r\n    const { maxHistory = 10 } = options;\r\n    const [state, setState] = useState(defaultValue);\r\n    const lastSaved = useRef(isFunction(defaultValue) ? defaultValue() : defaultValue);\r\n    const rerender = useState({})[1];\r\n    const actionHistory = useRef([]);\r\n    const redoHistory = useRef([]);\r\n    const redoAllowed = useRef(false);\r\n    const push = useCallback((value) => {\r\n        if (actionHistory.current.length < maxHistory) {\r\n            actionHistory.current.push(value);\r\n        }\r\n        else {\r\n            actionHistory.current = [...actionHistory.current.slice(1), value];\r\n            lastSaved.current = actionHistory.current[0];\r\n        }\r\n        redoAllowed.current = false;\r\n        setState(value);\r\n    }, [maxHistory]);\r\n    const redo = useCallback(() => {\r\n        if (!(redoHistory.current.length && redoAllowed.current))\r\n            return;\r\n        const lastUndoState = redoHistory.current.pop();\r\n        lastUndoState && push(lastUndoState);\r\n        redoAllowed.current = true;\r\n    }, [push]);\r\n    const undo = useCallback(() => {\r\n        if (actionHistory.current.length < 1)\r\n            return;\r\n        const lastState = actionHistory.current.pop();\r\n        lastState && redoHistory.current.push(lastState);\r\n        const prev = actionHistory.current[actionHistory.current.length - 1];\r\n        prev ? setState(prev) : setState(lastSaved.current);\r\n        rerender({});\r\n        redoAllowed.current = true;\r\n    }, [rerender]);\r\n    const reset = useCallback(() => {\r\n        var _a;\r\n        if (!((_a = actionHistory.current) === null || _a === void 0 ? void 0 : _a.length))\r\n            return;\r\n        setState(actionHistory.current[0]);\r\n        actionHistory.current = [actionHistory.current[0]];\r\n    }, []);\r\n    return {\r\n        state,\r\n        push,\r\n        undo,\r\n        redo,\r\n        reset,\r\n        history: actionHistory.current,\r\n        redoAllowed: redoAllowed.current\r\n    };\r\n}\n\n/**\r\n * Reactive document title hook\r\n *\r\n * Set title or observe dom mutation reactively\r\n *\r\n * @param newTitle optional\r\n * @see https://react-hooks-library.vercel.app/core/useTitle\r\n */\r\nfunction useTitle(newTitle) {\r\n    const [title, setTitle] = useState(newTitle !== null && newTitle !== void 0 ? newTitle : '');\r\n    useMount(() => {\r\n        var _a;\r\n        setTitle((_a = (newTitle || (_document === null || _document === void 0 ? void 0 : _document.title))) !== null && _a !== void 0 ? _a : '');\r\n    });\r\n    useEffect(() => {\r\n        document.title = title;\r\n    }, [title]);\r\n    useMutationObserver(_document === null || _document === void 0 ? void 0 : _document.head.querySelector('title'), () => {\r\n        if (document.title !== title)\r\n            setTitle(document.title);\r\n    }, { childList: true });\r\n    return { title, setTitle };\r\n}\n\n/**\r\n * A state toggle hook\r\n *\r\n * @param defaultValue\r\n * @default false\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useToggle\r\n */\r\nfunction useToggle(defaultValue = false) {\r\n    const [bool, setBool] = useState(defaultValue);\r\n    const toggle = useCallback(() => setBool((s) => !s), []);\r\n    const setTrue = useCallback(() => setBool(true), []);\r\n    const setFalse = useCallback(() => setBool(false), []);\r\n    return { bool, toggle, setTrue, setFalse };\r\n}\n\n/**\r\n * Reactive window size.\r\n *\r\n * @param options\r\n *\r\n * @see https://react-hooks-library.vercel.app/core/useWindowSize\r\n */\r\nfunction useWindowSize({ initialWidth = Infinity, initialHeight = Infinity } = {}) {\r\n    const [width, setWidth] = useState(initialWidth);\r\n    const [height, setHeight] = useState(initialHeight);\r\n    useMount(() => {\r\n        setWidth(window.innerWidth);\r\n        setHeight(window.innerHeight);\r\n    });\r\n    useEventListener('resize', () => {\r\n        setWidth(window.innerWidth);\r\n        setHeight(window.innerHeight);\r\n    }, { passive: true });\r\n    return { width, height };\r\n}\n\nexport { BreakPointHooks, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, useActiveElement, useAsyncCallback, useClickOutside, useDebounce, useEffectAfterMount, useEventListener, useFont, useHasMounted, useHover, useIntersectionObserver, useInterval, useIsSupported, useKeyDown, useKeyPressed, useKeyStroke, useKeyUp, useLocalStorage, useLocation, useMediaQuery, useMediaStream, useMount, useMountSync, useMouse, useMutationObserver, useNetwork, useOnline, usePreferredColorScheme, usePrevious, useScreenShare, useScroll, useScrollIntoView, useSessionStorage, useStateCompare, useStateHistory, useTitle, useToggle, useUnMount, useWindowSize };\n","import React, { useState } from 'react'\nimport { useInterval } from '@react-hooks-library/core'\n\nconst useIntervalWriteText = (\n  completedTitle: string,\n  useCompletedTitle?: boolean,\n) => {\n  const [landingTitle, setLadingTitle] = useState<string>('')\n  const [count, setCount] = useState<number>(0)\n\n  useInterval(() => {\n    if (count >= completedTitle.length) return\n\n    setLadingTitle(prev => {\n      let result = prev ? prev + completedTitle[count] : completedTitle[0]\n      setCount(prevCount => prevCount + 1)\n\n      return result\n    })\n  }, 150)\n\n  return useCompletedTitle ? completedTitle : landingTitle\n}\n\nexport default useIntervalWriteText\n","import { useEffect, useRef } from 'react'\n\nconst useScrollOrSwipeUp = (use: boolean, onWheelOrSwipeUp: () => void) => {\n  const touchStartY = useRef<number>(0)\n  const touchEndY = useRef(0)\n\n  const handleWheel = (event: Event) => {\n    const wheelEvent = event as WheelEvent\n    if (wheelEvent.deltaY > 0) {\n      onWheelOrSwipeUp()\n    }\n  }\n\n  const handleTouchStart = (event: TouchEvent) => {\n    touchStartY.current = event.touches[0].clientY\n  }\n\n  const handleTouchEnd = (event: TouchEvent) => {\n    touchEndY.current = event.changedTouches[0].clientY\n    if (touchStartY.current - touchEndY.current > 50) {\n      onWheelOrSwipeUp()\n    }\n  }\n\n  useEffect(() => {\n    if (use) {\n      window.addEventListener('wheel', handleWheel)\n      window.addEventListener('touchstart', handleTouchStart, { passive: true })\n      window.addEventListener('touchend', handleTouchEnd, { passive: true })\n    }\n\n    return () => {\n      window.removeEventListener('wheel', handleWheel)\n      window.removeEventListener('touchstart', handleTouchStart)\n      window.removeEventListener('touchend', handleTouchEnd)\n    }\n  }, [use, onWheelOrSwipeUp])\n}\n\nexport default useScrollOrSwipeUp\n","import React, {\n  FunctionComponent,\n  useCallback,\n  useEffect,\n  useState,\n} from 'react'\nimport styled from '@emotion/styled'\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faArrowsUpDown } from '@fortawesome/free-solid-svg-icons'\nimport { keyframes } from '@emotion/react'\nimport useIntervalWriteText from 'hooks/useIntervalWriteText'\nimport { cssState } from 'constants/type'\nimport useScrollOrSwipeUp from 'hooks/useScrollOrSwipeUp'\n\nconst Background = styled.div`\n  position: relative;\n  width: 100%;\n`\n\nconst Wrapper = styled.div<cssState>`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: flex-start;\n  max-width: 1100px;\n  height: ${props => (props.isActive ? '100vh' : '0px')};\n  margin: 0 auto;\n  transition: 1s;\n  gap: 10%;\n\n  @media (max-width: 1080px) {\n    width: 100%;\n    align-items: center;\n  }\n`\nconst TextArea = styled.div<cssState>`\n  opacity: ${props => (props.isActive ? 1 : 0)};\n  transition: opacity 1s;\n`\n\nconst Title = styled.strong`\n  font-size: 35px;\n\n  @media (max-width: 1080px) {\n    font-size: 25px;\n  }\n`\n\nconst arrowUpDownAnim = keyframes`\n  0% {\n    opacity: 1;\n    transform: translateY(-100%);\n  }\n  100% {\n    opacity: 1;\n    transform: translateY(0%);\n  }\n`\nconst DownIconArea = styled.div`\n  display: flex;\n  width: 80%;\n  height: 40px;\n  justify-content: flex-end;\n\n  @media (max-width: 1080px) {\n    justify-content: center;\n  }\n`\nconst DownIcon = styled.div<cssState>`\n  display: flex;\n  justify-items: flex-end;\n  animation: ${props => (props.isActive ? arrowUpDownAnim : 'none')} 1s 0s\n    infinite alternate-reverse;\n  opacity: ${props => (props.isActive ? 1 : 0)};\n  transition: opacity 1s;\n\n  &:hover {\n    animation-play-state: paused;\n  }\n\n  @media (max-width: 1080px) {\n    justify-content: center;\n  }\n`\nconst DownIconBtn = styled.button`\n  padding: 8px 5px;\n  border: 0.2rem solid #000;\n  border-radius: 20px;\n  /* box-shadow: 0 0 0.1rem #fff, 0 0 0.1rem #fff, 0 0 1rem #ff0080,\n    0 0 0.4rem #ff0080, 0 0 1.4rem #ff0080, inset 0 0 0.6rem #ff0080; */\n`\n\ntype IntroductionProps = {\n  isIntro: boolean\n  hideIntro: () => void\n}\nconst welcomeText = 'Welcome to TH Dev Note.'\nconst Introduction: FunctionComponent<IntroductionProps> = ({\n  isIntro,\n  hideIntro,\n}) => {\n  const [showInfoText, setShowInfoText] = useState<boolean>(false)\n\n  useScrollOrSwipeUp(showInfoText === true && isIntro === true, hideIntro)\n\n  useEffect(() => {\n    setTimeout(() => {\n      setShowInfoText(true)\n    }, welcomeText.length * 150 + 500)\n  }, [])\n\n  return (\n    <Background>\n      <Wrapper isActive={isIntro}>\n        <TextArea isActive={isIntro}>\n          <Title>{useIntervalWriteText(welcomeText, !isIntro)}</Title>\n        </TextArea>\n        <DownIconArea>\n          {showInfoText && (\n            <DownIcon onClick={hideIntro} isActive={isIntro}>\n              <DownIconBtn>\n                <FontAwesomeIcon icon={faArrowsUpDown} color={'#000'} />\n              </DownIconBtn>\n            </DownIcon>\n          )}\n        </DownIconArea>\n      </Wrapper>\n    </Background>\n  )\n}\n\nexport default Introduction\n","import React, { FunctionComponent } from 'react'\nimport styled from '@emotion/styled'\nimport { Link } from 'gatsby'\n\nimport { GatsbyImage } from 'gatsby-plugin-image'\nimport { PostFrontmatterType } from 'types/PostItem.types'\nimport { GatsbyLinkProps } from './CategoryList'\nimport { cssState } from 'constants/type'\n\ntype PostItemProps = PostFrontmatterType & {\n  link: string\n  selectedCategory?: string\n}\n\nconst PostItemWrapper = styled(({ ...props }: GatsbyLinkProps) => (\n  <Link {...props} />\n))`\n  display: flex;\n  flex-direction: column;\n  border: 1px solid #ddd;\n  border-radius: 10px;\n  box-shadow: 0 0 8px rgba(0, 0, 0, 0.15);\n  overflow: hidden;\n  cursor: pointer;\n\n  &:hover {\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n  }\n  &:hover img {\n    transform: scale(1.1);\n    transition: 0.4s;\n  }\n  &:not(:hover) img {\n    transform: scale(1);\n    transition: 0.4s;\n  }\n`\nconst PostItemInfo = styled.div`\n  display: flex;\n  flex: 1;\n  flex-direction: column;\n  padding: 5%;\n`\nconst ThumbnailImage = styled(GatsbyImage)`\n  border-radius: 4px 4px 0 0;\n  object-fit: cover;\n  transition: 0.4s transform;\n`\nconst PostItemInfoText = styled.div`\n  flex: 0.5;\n  display: flex;\n  align-items: flex-end;\n  justify-content: space-between;\n  padding: 5px 0;\n`\n\nconst Title = styled.div`\n  display: -webkit-box;\n  overflow: hidden;\n  margin-bottom: 3px;\n  text-overflow: ellipsis;\n  white-space: normal;\n  overflow-wrap: break-word;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  font-size: 18px;\n  font-weight: 700;\n`\n\nconst Date = styled.div`\n  font-size: 14px;\n  font-weight: 400;\n  opacity: 0.7;\n`\n\nconst Category = styled.div`\n  display: flex;\n  flex-wrap: wrap;\n  margin-top: 10px;\n  gap: 5px;\n`\n\nconst CategoryItem = styled.div`\n  padding: 3px 5px;\n  border-radius: 3px;\n  background: black;\n  font-size: 14px;\n  font-weight: 700;\n  color: white;\n`\n\nconst Summary = styled.div<cssState>`\n  display: -webkit-box;\n  overflow: hidden;\n  margin: auto 0;\n  text-overflow: ellipsis;\n  white-space: normal;\n  overflow-wrap: break-word;\n  -webkit-line-clamp: ${props => (props.hasImg ? 2 : 6)};\n  -webkit-box-orient: vertical;\n  opacity: 0.8;\n`\nconst PostItem: FunctionComponent<PostItemProps> = ({\n  title,\n  date,\n  categories,\n  summary,\n  thumbnail,\n  link,\n  selectedCategory,\n}) => {\n  return (\n    <PostItemWrapper to={`${link}?category=${selectedCategory}`}>\n      {thumbnail && thumbnail.childImageSharp.gatsbyImageData ? (\n        <ThumbnailImage\n          image={thumbnail.childImageSharp.gatsbyImageData}\n          alt=\"Post Item Image\"\n        />\n      ) : null}\n      <PostItemInfo>\n        <Title>{title}</Title>\n        <PostItemInfoText>\n          <Category>\n            {categories.map(category => (\n              <CategoryItem key={category}>{category}</CategoryItem>\n            ))}\n          </Category>\n          <Date>{date}</Date>\n        </PostItemInfoText>\n        <Summary hasImg={thumbnail ? true : false}>{summary}</Summary>\n      </PostItemInfo>\n    </PostItemWrapper>\n  )\n}\n\nexport default PostItem\n","import React, {\n  MutableRefObject,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport { PostListItemType } from 'types/PostItem.types'\n\nexport type useInfiniteScrollType = {\n  containerRef: MutableRefObject<HTMLDivElement | null>\n  postList: PostListItemType[]\n}\n\nconst NUMBER_OF_ITEMS_PER_PAGE = 10\n\nconst useInfiniteScroll = (\n  selectedCategory: string,\n  posts: PostListItemType[],\n): useInfiniteScrollType => {\n  const containerRef: MutableRefObject<HTMLDivElement | null> =\n    useRef<HTMLDivElement>(null)\n  const observer: MutableRefObject<IntersectionObserver | null> =\n    useRef<IntersectionObserver>(null)\n  const [count, setCount] = useState<number>(1)\n\n  const postListByCategory = useMemo<PostListItemType[]>(() => {\n    return posts.filter(\n      ({\n        node: {\n          frontmatter: { categories },\n        },\n      }: PostListItemType) =>\n        selectedCategory !== 'All'\n          ? categories?.includes(selectedCategory)\n          : true,\n    )\n  }, [selectedCategory])\n\n  useEffect(() => {\n    observer.current = new IntersectionObserver((entries, observer) => {\n      if (!entries[0].isIntersecting) return\n\n      setCount(value => value + 1)\n      observer.unobserve(entries[0].target)\n    })\n  }, [])\n\n  useEffect(() => setCount(1), [selectedCategory])\n\n  useEffect(() => {\n    if (\n      NUMBER_OF_ITEMS_PER_PAGE * count >= postListByCategory.length ||\n      containerRef.current === null ||\n      containerRef.current.children.length === 0 ||\n      observer.current === null\n    )\n      return\n\n    observer.current.observe(\n      containerRef.current.children[containerRef.current.children.length - 1],\n    )\n  }, [count, selectedCategory])\n\n  return {\n    containerRef,\n    postList: postListByCategory.slice(0, count * NUMBER_OF_ITEMS_PER_PAGE),\n  }\n}\n\nexport default useInfiniteScroll\n","import React, { FunctionComponent, useMemo } from 'react'\nimport styled from '@emotion/styled'\n\nimport PostItem from './PostItem'\nimport { PostListItemType } from 'types/PostItem.types'\nimport useInfiniteScroll, {\n  useInfiniteScrollType,\n} from 'hooks/useInfiniteScroll'\n\ntype PostListProps = {\n  selectedCategory: string\n  posts: PostListItemType[]\n}\n\nconst PostListWrapper = styled.div`\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-gap: 3em;\n  max-width: 1100px;\n  margin: 0 auto;\n  padding: 100px 0;\n\n  @media (max-width: 1080px) {\n    grid-template-columns: 1fr 1fr;\n    grid-gap: 2% 5%;\n    padding: 70px 20px;\n  }\n\n  @media (max-width: 768px) {\n    grid-template-columns: 1fr;\n    grid-gap: 1% 2%;\n    width: 100%;\n    padding: 70px 20px;\n  }\n`\n\nconst PostList: FunctionComponent<PostListProps> = function ({\n  selectedCategory,\n  posts,\n}) {\n  const { containerRef, postList }: useInfiniteScrollType = useInfiniteScroll(\n    selectedCategory,\n    posts,\n  )\n  return (\n    <PostListWrapper ref={containerRef}>\n      {postList\n        .filter(i => i.node.frontmatter.categories?.length > 0)\n        .map(\n          ({\n            node: {\n              id,\n              fields: { slug },\n              frontmatter,\n            },\n          }: PostListItemType) => {\n            return (\n              <PostItem\n                {...frontmatter}\n                link={slug}\n                key={id}\n                selectedCategory={selectedCategory}\n              />\n            )\n          },\n        )}\n    </PostListWrapper>\n  )\n}\n\nexport default PostList\n","import React, {\n  FunctionComponent,\n  useCallback,\n  useEffect,\n  useState,\n} from 'react'\nimport { graphql } from 'gatsby'\nimport { IGatsbyImageData } from 'gatsby-plugin-image'\n\nimport Template from 'components/Common/Template'\nimport Introduction from 'components/Main/Introduction'\nimport PostList from 'components/Main/PostList'\nimport { PostListItemType } from 'types/PostItem.types'\nimport { useSelectedCategory } from 'hooks/useCategories'\n\ntype IndexPageProps = {\n  location: {\n    search: string\n  }\n  data: {\n    site: {\n      siteMetadata: {\n        title: string\n        description: string\n        siteUrl: string\n      }\n    }\n    allMarkdownRemark: {\n      edges: PostListItemType[]\n    }\n    file: {\n      childImageSharp: {\n        gatsbyImageData: IGatsbyImageData\n      }\n      publicURL: string\n    }\n  }\n}\n\nconst IndexPage: FunctionComponent<IndexPageProps> = function ({\n  location: { search },\n  data: {\n    site: {\n      siteMetadata: { title, description, siteUrl },\n    },\n    allMarkdownRemark: { edges },\n    file: {\n      childImageSharp: { gatsbyImageData },\n      publicURL,\n    },\n  },\n}) {\n  const selectedCategory = useSelectedCategory(search)\n\n  const initIntroState =\n    typeof window !== 'undefined'\n      ? sessionStorage.getItem('initIntroState')\n      : null\n  const [isIntro, setIsIntro] = useState<boolean>(\n    initIntroState === 'false' ? false : true,\n  )\n\n  const hideIntro = useCallback(() => {\n    if (isIntro === true) {\n      setIsIntro(false)\n      sessionStorage.setItem('initIntroState', 'false')\n      setTimeout(() => {\n        document.body.style.overflow = 'auto'\n      }, 1000)\n    }\n  }, [])\n\n  useEffect(() => {\n    if (isIntro === true) {\n      document.body.style.overflow = 'hidden'\n    }\n  }, [])\n\n  return (\n    <Template\n      title={title}\n      description={description}\n      url={siteUrl}\n      image={publicURL}\n      isIntro={isIntro}\n    >\n      <Introduction isIntro={isIntro} hideIntro={hideIntro} />\n      <PostList selectedCategory={selectedCategory} posts={edges} />\n    </Template>\n  )\n}\n\nexport default IndexPage\n\nexport const getPostList = graphql`\n  query getPostList {\n    site {\n      siteMetadata {\n        title\n        description\n        siteUrl\n      }\n    }\n    allMarkdownRemark(\n      sort: [{ frontmatter: { date: DESC } }, { frontmatter: { title: DESC } }]\n    ) {\n      edges {\n        node {\n          id\n          fields {\n            slug\n          }\n          frontmatter {\n            title\n            summary\n            date(formatString: \"YYYY.MM.DD\")\n            categories\n            thumbnail {\n              childImageSharp {\n                gatsbyImageData(width: 768, height: 400)\n              }\n            }\n          }\n        }\n      }\n    }\n    file(name: { eq: \"introduceBg\" }) {\n      childImageSharp {\n        gatsbyImageData\n      }\n      publicURL\n    }\n  }\n`\n"],"names":["isClient","window","document","navigator","useIntervalWriteText","completedTitle","useCompletedTitle","landingTitle","setLadingTitle","useState","count","setCount","callback","delay","options","immediate","paused","savedCallback","useRef","tickId","useEffect","current","setInterval","clearInterval","useInterval","length","prev","result","prevCount","useScrollOrSwipeUp","use","onWheelOrSwipeUp","touchStartY","touchEndY","handleWheel","event","deltaY","handleTouchStart","touches","clientY","handleTouchEnd","changedTouches","addEventListener","passive","removeEventListener","Background","_styled","target","name","styles","Wrapper","props","isActive","TextArea","Title","arrowUpDownAnim","keyframes","DownIconArea","DownIcon","DownIconBtn","welcomeText","_ref","isIntro","hideIntro","showInfoText","setShowInfoText","setTimeout","___EmotionJSX","onClick","FontAwesomeIcon","icon","faArrowsUpDown","color","PostItemWrapper","Link","PostItemInfo","ThumbnailImage","GatsbyImage","PostItemInfoText","Date","Category","CategoryItem","Summary","hasImg","_ref2","title","date","categories","summary","thumbnail","link","selectedCategory","to","childImageSharp","gatsbyImageData","image","alt","map","category","key","useInfiniteScroll","posts","containerRef","observer","postListByCategory","useMemo","filter","node","frontmatter","includes","IntersectionObserver","entries","isIntersecting","value","unobserve","children","observe","postList","slice","PostListWrapper","ref","i","_i$node$frontmatter$c","id","fields","slug","PostItem","_extends","location","search","data","site","siteMetadata","description","siteUrl","allMarkdownRemark","edges","file","publicURL","useSelectedCategory","initIntroState","sessionStorage","getItem","setIsIntro","useCallback","setItem","body","style","overflow","Template","url","Introduction","PostList"],"sourceRoot":""}